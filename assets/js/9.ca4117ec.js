(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{408:function(s,t,a){"use strict";a.r(t);var e=a(56),n=Object(e.a)({},(function(){var s=this,t=s.$createElement,a=s._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h3",{attrs:{id:"git-hooks"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#git-hooks"}},[s._v("#")]),s._v(" git-hooks")]),s._v(" "),a("p",[s._v('我们回到项目的根目录下。运行 ls -a 命令 ———— “-a”可以显示隐藏目录(目录名的第一位是.)。\n我们可以看到，存在一个".git"名称的文件夹。\n事实上，在我们项目中根目录下运行 git 命令时，git 会根据它来工作。\n接来下我们进入到这个文件夹，进一步查看它内部的内容。')]),s._v(" "),a("div",{staticClass:"language-shell extra-class"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v("cd")]),s._v(" .git\n"),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("ls")]),s._v(" -a\n")])])]),a("p",[s._v("我们发现它内部还挺有料！不慌，我们这节课仅仅只讲到其中的一个内容 ———— hooks\n可以看到，当前目录下存在一个 hooks 文件夹，顾名思义，这个文件夹提供了 git 命令相关的钩子。\n继续往里看。")]),s._v(" "),a("div",{staticClass:"language-shell extra-class"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v("cd")]),s._v(" hooks\n"),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("ls")]),s._v(" -a\n")])])]),a("p",[s._v('ok，那我们我们可以看到有很多 git 命令相关的文件名。比如"pre-commit.sample pre-push.sample"。\n回到正题——我们期望在 git 提交(commit)前，对我们的代码进行检测，如果不能通过检测，就无法提交我们的代码。\n那么自然而然的，这个动作的时机应该是？————"pre commit",也就是 commit 之前。\n那么现在，我们查看一下 pre-commit.sample 的内容。')]),s._v(" "),a("div",{staticClass:"language-shell extra-class"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# cat命令可以查看一个文件的内容")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("cat")]),s._v(" pre-commit.sample\n")])])]),a("p",[s._v("OK，它返回了这样的内容，是一串 shell 注释。翻译过来大概意思是，这是个示例钩子，然后我们看到了这一句话")]),s._v(" "),a("div",{staticClass:"language-shell extra-class"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[s._v('# To enable this hook, rename this file to "pre-commit".')]),s._v("\n")])])]),a("p",[s._v("意思是要启用这个钩子的话，我们就把这个文件的后缀名去掉。")]),s._v(" "),a("p",[s._v("虽然这样对我们本地来讲是可行的，但要注意，.git 文件夹的改动无法同步到远端仓库。\n所以我们期望将 git-hook 的执行权移交到外面来。")]),s._v(" "),a("p",[s._v('好的，我们回到项目的根目录下,然后我们新建一个文件夹，暂时命名为".mygithooks"\n然后在此文件夹下，新增一个 git-hook 文件,命名为"pre-commit"，并写入以下内容：')]),s._v(" "),a("div",{staticClass:"language-shell extra-class"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v("echo")]),s._v(" pre-commit执行啦\n")])])]),a("p",[s._v("好了，我们新建了自己的 git-hook，但此时 git 并不能识别。下面我们执行这行命令：")]),s._v(" "),a("div",{staticClass:"language-shell extra-class"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 项目根目录下")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("git")]),s._v(" config core.hooksPath .mygithooks/pre-commit\n")])])]),a("p",[s._v("上述命令给我们自己的文件，配置了 git-hook 的执行权限。")]),s._v(" "),a("p",[s._v("但这个时候我们 git commit 的话，可能会报这样的 waring，并且没有执行我们的 shell：")]),s._v(" "),a("div",{staticClass:"language-shell extra-class"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[s._v("hint: The "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v("'pre-commit'")]),s._v(" hook was ignored because it's not "),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v("set")]),s._v(" as executable.\nhint: You can disable this warning with "),a("span",{pre:!0,attrs:{class:"token variable"}},[a("span",{pre:!0,attrs:{class:"token variable"}},[s._v("`")]),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("git")]),s._v(" config advice.ignoredHook "),a("span",{pre:!0,attrs:{class:"token boolean"}},[s._v("false")]),a("span",{pre:!0,attrs:{class:"token variable"}},[s._v("`")])]),s._v("\n")])])]),a("p",[s._v("这是因为我们的操作系统没有给出这个文件的可执行权限。\n因此我们得再执行这样一句命令：")]),s._v(" "),a("div",{staticClass:"language-shell extra-class"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[a("span",{pre:!0,attrs:{class:"token function"}},[s._v("chmod")]),s._v(" +x .mygithooks/pre-commit\n")])])]),a("p",[s._v('ok！现在我们尝试执行 git add . && git commit -m "any meesage"\n我们发现控制台日志会先打印 “pre-commit 执行啦”\n这意味着成功啦！')]),s._v(" "),a("h3",{attrs:{id:"总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[s._v("#")]),s._v(" 总结")]),s._v(" "),a("p",[s._v("也就是说，我们搞 git-hook 的话，要分三步走：")]),s._v(" "),a("ol",[a("li",[s._v("新增任意名称文件夹以及文件 pre-commit(这个文件名字比如跟要使用的 git-hook 名字一致)！")]),s._v(" "),a("li",[s._v("执行以下命令来移交 git-hook 的配置权限")])]),s._v(" "),a("div",{staticClass:"language-shell extra-class"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[a("span",{pre:!0,attrs:{class:"token function"}},[s._v("git")]),s._v(" config core.hooksPath .mygithooks/pre-commit\n")])])]),a("ol",{attrs:{start:"3"}},[a("li",[s._v("给这个文件添加可执行权限：")])]),s._v(" "),a("div",{staticClass:"language-shell extra-class"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[a("span",{pre:!0,attrs:{class:"token function"}},[s._v("chmod")]),s._v(" +x .mygithooks/pre-commit\n")])])]),a("p",[s._v("然后就成功啦。")]),s._v(" "),a("p",[s._v("这时候我们可以在 pre-commit 里写任意脚本，比如：")]),s._v(" "),a("div",{staticClass:"language-shell extra-class"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[s._v("eslint src\n")])])]),a("p",[s._v("当 eslint 扫描代码，出现 error 时，会在结束扫描时将退出码设为大于 0 的数字。\n也就是会报错，这时候 commit 就无法往下执行啦，我们成功的拦截了此次错误操作。")]),s._v(" "),a("h3",{attrs:{id:"husky"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#husky"}},[s._v("#")]),s._v(" husky")]),s._v(" "),a("p",[s._v("husky 在升级到 7.x 后，做了跟我们上述同样的事。\n安装它之前，我们需要在 package.json 中的 script 里，先添加")]),s._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token string-property property"}},[s._v('"sctript"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("//...others")]),s._v("\n    "),a("span",{pre:!0,attrs:{class:"token string-property property"}},[s._v('"prepare"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"husky install"')]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])])]),a("p",[s._v("prepare 是一个 npm 钩子，意思是安装依赖的时候，会先执行 husky install 命令。\n这个命令就做了上述的 123 这三件事！\n我们安装了 7.x 的 husky 会发现，项目根目录下生成了.husky 的文件夹。\n当然，7.x 的 husky 似乎是有 bug 的，如果不能正常使用，那么我们只需要验证两件事：")]),s._v(" "),a("ol",[a("li",[s._v('是否移交了 git-hook 的配置权限？\n执行命令 "git config --list"查看 core.hooksPath 配置是否存在，是否正确指向了.husky。\n如果没有，我们只需要手动的给加上就行：')])]),s._v(" "),a("div",{staticClass:"language-shell extra-class"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[a("span",{pre:!0,attrs:{class:"token function"}},[s._v("git")]),s._v(" config core.hooksPath .husky\n")])])]),a("ol",{attrs:{start:"2"}},[a("li",[s._v("是否是可执行文件？\n参考上述总结中的 3 即可\n这时我们的 husky 就正常了。")])]),s._v(" "),a("h3",{attrs:{id:"melody-core-melody-git-hook"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#melody-core-melody-git-hook"}},[s._v("#")]),s._v(" @melody-core/melody-git-hook")]),s._v(" "),a("p",[s._v("这是我连夜撸出来的一个工具，跟 husky 有一样的功能。但没有这么多 bug。\n可以参考这个文档来使用它\nhttps://github.com/melody-core/melody-git-hook")])])}),[],!1,null,null,null);t.default=n.exports}}]);